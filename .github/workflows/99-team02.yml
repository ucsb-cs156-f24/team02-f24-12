name: 99 - Create Issues for team02

env:
<<<<<<< HEAD
  GH_TOKEN: ${{ github.token }}
  ASSIGNMENT: team02
  PREV_ASSIGNMENT: team01
  ASN_LINK: https://ucsb-cs156.github.io/f24/lab/team02
  STARTER_REPO: "ucsb-cs156-f24/STARTER-team02"
  FRONTEND_URL: '{ "UCSBDiningCommonsMenuItem": "diningcommonsmenuitem", "UCSBOrganization": "ucsborganization", "RecommendationRequest": "recommendationrequest", "MenuItemReview": "menuitemreview", "HelpRequest": "helprequest", "Articles": "articles" }'
  FIXTURES: '{ "UCSBDiningCommonsMenuItem": "ucsbDiningCommonsMenuItem", "UCSBOrganization": "ucsbOrganization", "RecommendationRequest": "recommendationRequest", "MenuItemReview": "menuItemReview", "HelpRequest": "helpRequest", "Articles": "articles" }'
  LABEL_COLOR: '{ "UCSBDiningCommonsMenuItem": "ff0000", "UCSBOrganization": "00ff00", "RecommendationRequest": "0000ff", "MenuItemReview": "ff00ff", "HelpRequest": "ffff00", "Articles": "00ffff" }'
  REPO_FILE: https://github.com/${{github.repository}}/blob/main
  NVM_USE: "`nvm use 20.17.0`"
  SAMPLE_TEAM: f24-05
=======
  ASN_LINK: https://ucsb-cs156.github.io/s24/lab/team02
  GH_TOKEN: ${{ github.token }}
  LABEL_COLOR: "{ \"UCSBDiningCommonsMenuItem\": \"ff0000\", \"UCSBOrganization\": \"00ff00\", \"RecommendationRequest\": \"0000ff\", \"MenuItemReview\": \"ff00ff\", \"HelpRequest\": \"ffff00\", \"Articles\": \"00ffff\" }"


>>>>>>> starter/main
on:
  workflow_dispatch:
jobs:
  createOneOffIssues:
    runs-on: ubuntu-latest

    steps:
<<<<<<< HEAD
      - uses: actions/checkout@v4
=======
      - uses: actions/checkout@v3
>>>>>>> starter/main
      - name: Delete label setup
        continue-on-error: true
        run: |
          gh api \
<<<<<<< HEAD
                --method DELETE \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                /repos/${{github.repository}}/labels/setup
=======
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{github.repository}}/labels/setup 
>>>>>>> starter/main
      - name: Add Label setup
        continue-on-error: true
        run: |
          gh api \
<<<<<<< HEAD
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{github.repository}}/labels \
            -f name='setup' \
            -f description='One time tasks to divide among all team members' \
            -f color='dddddd'

=======
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{github.repository}}/labels \
              -f name='setup' \
              -f description='One time tasks to divide among all team members' \
              -f color='dddddd' 
>>>>>>> starter/main
      - name: Add table to README.md
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ github.token }}
          title: Add table to README.md
          labels: "setup"
          body: |
            # Acceptance Criteria:
            - [ ] The README.md has a table at the top like the one shown below
                  indicating which team member is initially taking on
                  which database table, and which is unassigned.
                  
                  ```
                  | Table                       | Team Member  | Github Id     |
                  |-----------------------------|--------------|---------------|
                  | `UCSBDiningCommonsMenuItem` | Alice        | alice33       |
                  | `UCSBOrganization`          | (unassigned) |               |
                  | `RecommendationRequest`     | Bob          | robertg       |
                  | `MenuItemReview`            | Charlie      | gauchocharlie |
                  | `HelpRequest`               | Danielle     | danielle      |
                  | `Articles`                  | Eddie        | eddydp        |
                  ```

      - name: Set up GitHub Pages
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ github.token }}
          title: Set up Github Pages
          labels: "setup"
          body: |
            # Acceptance Criteria:
            - [ ] Github Pages is active, using the `gh-pages` branch and the root directory
            - [ ] The main page of the repo has a link to the Github Pages site in the right side bar
            - [ ] The links on the Github Pages site work properly.
            - [ ] A `PROJECT_CHROMATIC_TOKEN` value is set correctly for the team's repo (this only needs to be done once)

            # Details

<<<<<<< HEAD
            See the file  [`docs/github-pages.md`](/${{env.STARTER_REPO}}/blob/main/docs/github-pages.md) in the repo for details

=======
            See the file  [`docs/github-pages.md`](/ucsb-cs156-s24/STARTER-team02/blob/main/docs/github-pages.md) in the repo for details
      
>>>>>>> starter/main
      - name: Set up Team prod deployment
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ github.token }}
          title: Set up Team prod deployment
          labels: "setup"
          body: |
            # Acceptance Criteria:
            - [ ] An app named <tt>${{env.ASSIGNMENT}}</tt> is created on this team's dokku server.
            - [ ] An database is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/postgres_database.html>)
            - [ ] The ADMIN_EMAILS are configured for that app.
                  * You should find the ones you need in a pinned post on your team's Slack channel.
                  * Instructions for configuring the variable are here: 
                    <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] Google OAuth is configured for that app.
                  * Instructions for configuring OAuth credentials are here: 
                    <https://ucsb-cs156.github.io/topics/oauth/oauth_google_setup.html>
                  * Then you need to use the instructions here to configure the environment variables `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] HTTPS is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/enabling_https.html>)
            - [ ] The main branch is deployed on Dokku at, for example,
                  <https://${{env.ASSIGNMENT}}.dokku-xx.cs.ucsb.edu> (substituting your
                  own Dokku instances for xx).
            - [ ] Everyone on the team, and the instructor and TAs, are all able to 
                  login with OAuth and see that they have admin privileges.

            # Details

<<<<<<< HEAD
            See the file  [`docs/dokku.md`](/${{env.STARTER_REPO}}/blob/main/docs/dokku.md) in the repo for details.
=======
            See the file  [`docs/dokku.md`](/ucsb-cs156-s24/STARTER-team02/blob/main/docs/dokku.md) in the repo for details.
>>>>>>> starter/main

      - name: Set up Team qa deployment
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ github.token }}
          title: Set up Team qa deployment
          labels: "setup"
          body: |
            # Acceptance Criteria:

            - [ ] An app named <tt>${{env.ASSIGNMENT}}-qa</tt> is created on this team's dokku server.
            - [ ] An database is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/postgres_database.html>)
            - [ ] The ADMIN_EMAILS are configured for that app.
                  * You should find the ones you need in a pinned post on your team's Slack channel.
                  * Instructions for configuring the variable are here: 
                    <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] Google OAuth is configured for that app.
                  * Instructions for configuring OAuth credentials are here: 
                    <https://ucsb-cs156.github.io/topics/oauth/oauth_google_setup.html>
                  * Then you need to use the instructions here to configure the environment variables `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] The main branch is deployed on Dokku at, for example,
                  <https://${{env.ASSIGNMENT}}-qa.dokku-xx.cs.ucsb.edu> (substituting your
                  own Dokku instances for xx).
            - [ ] Everyone on the team, and the instructor and TAs, are all able to 
                  login with OAuth and see that they have admin privileges.
<<<<<<< HEAD
            - [ ] HTTPS is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/enabling_https.html>)
=======
>>>>>>> starter/main
                  

            # Details

            Set up a separate Dokku instance for QA.  Adapt the instructions from 
<<<<<<< HEAD
            the file [`docs/dokku.md`](/${{env.STARTER_REPO}}/blob/main/docs/dokku.md) in the repo.  The QA (quality assurance) instance
=======
            the file [`docs/dokku.md`](/ucsb-cs156-s24/STARTER-team02/blob/main/docs/dokku.md) in the repo.  The QA (quality assurance) instance
>>>>>>> starter/main
            starts with the main branch, but later on, you will be able to deploy
            any branch to this instance. You typically do this when you have a PR
            that is being code reviewed.  You can use the your team's Slack channel
            to coordinate who is deploying what to QA at any given time.

      - name: Adjust links in README.md
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ github.token }}
          title: Adjust title and links in README.md
          labels: "setup"
          body: |
            ## Acceptance criteria
<<<<<<< HEAD
            - [ ] The title of the README.md file is changed from <tt>STARTER-${{env.ASSIGNMENT}}</tt> to the name of the app (e.g. <tt>${{env.ASSIGNMENT}}-${{env.SAMPLE_TEAM}}</tt>)
=======
            - [ ] The title of the README.md file is changed from `STARTER-team02` to the name of the app (e.g. `team02-s24-6pm-4`)
>>>>>>> starter/main
            - [ ] The README.md file is updated with links to the prod and qa instances on dokku.
            - [ ] The README.md file is updated with any other links as specified in the instructions.

            ## Details

            See the README.md file in the repo for details.

      - name: Submit for Grading
        uses: dacbd/create-issue-action@main
        with:
          token: ${{ github.token }}
<<<<<<< HEAD
          title: Submit for Grading
=======
          title:  Submit for Grading
>>>>>>> starter/main
          labels: "setup"
          body: |

            This issue should be the very *last* one that the team drags into the "done" column;
            it signifies that the sprint is complete, and that the project is ready for the
            staff to review it for a grade.

            ## Acceptance criteria
<<<<<<< HEAD

            - [ ] All PRs have been code reviewed and merged to main
            - [ ] All issues are in the done column 
            - [ ] The `main` branch (after all PRs merged) has been reployed to the dokku instance with the <tt>dokku git:sync ${{env.ASSIGNMENT}} <i>url</i> main</tt> and <tt>dokku ps:rebuild ${{env.ASSIGNMENT}}</tt> commands
=======
  
            - [ ] All PRs have been code reviewed and merged to main
            - [ ] All issues are in the done column 
            - [ ] The `main` branch (after all PRs merged) has been reployed to the dokku instance via:
                  <tt>dokku git:sync team02 <i>url</i> main</tt><br />
                  <tt>dokku ps:rebuild team02</tt>
>>>>>>> starter/main
            - [ ] The assignment has been submitted on Canvas

            ## Details

            See the assignment description at ${{env.ASN_LINK}} for details.

  createIssues:
    needs: [createOneOffIssues]
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      matrix:
        api:
          [
            "UCSBDiningCommonsMenuItem",
            "UCSBOrganization",
            "RecommendationRequest",
            "MenuItemReview",
            "HelpRequest",
            "Articles",
          ]

    steps:
<<<<<<< HEAD
      - uses: actions/checkout@v4
      - name: Delete Label for ${{ matrix.api }}
        continue-on-error: true
        env:
          token: ${{ github.token }}
=======
    
      - uses: actions/checkout@v3
      - name: Delete Label for ${{ matrix.api }}
        continue-on-error: true
        env:
>>>>>>> starter/main
          name: ${{ matrix.api }}
          color: ${{ fromJSON(env.LABEL_COLOR)[matrix.api] }}
        run: |
          gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
<<<<<<< HEAD
              /repos/${{github.repository}}/labels/${{env.name}}
      - name: Create Label
        env:
          token: ${{ github.token }}
=======
              /repos/${{github.repository}}/labels/${{env.name}} 
      - name: Create Label
        env:
>>>>>>> starter/main
          name: ${{ matrix.api }}
          color: ${{ fromJSON(env.LABEL_COLOR)[matrix.api] }}
        run: |
          gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{github.repository}}/labels \
              -f name='${{env.name}}' \
<<<<<<< HEAD
              -f description='${{env.ASSIGNMENT}} issues for ${{env.name}}' \
              -f color='${{env.color}}'

      - name: Create personal dokku dev deployment
=======
              -f description='team02 issues for ${{env.name}}' \
              -f color='${{env.color}}' 
      - name: Create personal dokku dev deployment
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
        with:
          token: ${{ github.token }}
          title: "${{env.name}} - Create personal dokku dev deployment"
          labels: "${{env.name}}"
          body: |

            # Dependencies

            None: The team member that takes on ${{env.name}} should start with this issue.

            # Overview

            The team member that takes on ${{env.name}} as their database table
            should use this issue to track creating their personal dokku
            deployment.
            
            # Acceptance Criteria:
            - [ ] An app named `team02-YOURGITHUBID-dev` is created on this team's dokku server, where
                  `YOURGITHUBID` is your github id.

            - [ ] An database is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/postgres_database.html>)
            - [ ] HTTPS is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/enabling_https.html>)
            - [ ] The ADMIN_EMAILS are configured for that app.
                  * You should find the ones you need in a pinned post on your team's Slack channel.
                  * Instructions for configuring the variable are here: 
                    <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] Google OAuth is configured for that app.
                  * Instructions for configuring OAuth credentials are here: 
                    <https://ucsb-cs156.github.io/topics/oauth/oauth_google_setup.html>
                  * Then you need to use the instructions here to configure the environment variables `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] Everyone on the team, and the instructor and TAs, are all able to 
                  login with OAuth and see that they have admin privileges.
            - [ ] Initially, the `main` branch is deployed and works properly (later, you will deploy your own branches to this 
                  instance as you test them before merging.)     
            # Next issue

            Next, work on 

            * Drag the issue for "${{env.name}} - Create personal dokku dev deployment" directly into the "Done" column (we don't do code review on setup tasks like this one.)
            * Locate the issue: "Create database table for ${{env.name}}" on the Kanban board.
            * Assign that issue to yourself
            * Drag it into the "In Progress" column.
            * Start a new branch.  The new branch name is something like `xy-${{env.name}}-create-db`
              <pre>
              git fetch
              git checkout main
              git pull origin main
              git checkout -b <i>your-branch-name</i>
              </pre>
            * Start on the next issue
                        
      - name: Create database table
>>>>>>> starter/main
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
        with:
          token: ${{ github.token }}
<<<<<<< HEAD
          labels: "${{env.name}}"
          title: "${{env.name}} - Create personal dokku dev deployment"
=======
          title: Create database table for ${{env.name}}
          labels: "${{env.name}}"
>>>>>>> starter/main
          body: |

            # Dependencies

<<<<<<< HEAD
            None: The team member that takes on ${{env.name}} should start with this issue.

            # Overview

            The team member that takes on ${{env.name}} as their database table
            should use this issue to track creating their personal dokku
            deployment.

            # Acceptance Criteria:
            - [ ] An app named <tt>${{env.ASSIGNMENT}}-YOURGITHUBID-dev</tt> is created on this team's dokku server, where
                  `YOURGITHUBID` is your github id.
            - [ ] An database is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/postgres_database.html>)
            - [ ] The ADMIN_EMAILS are configured for that app.
                  * You should find the ones you need in a pinned post on your team's Slack channel.
                  * Instructions for configuring the variable are here: <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] Google OAuth is configured for that app.
                  * Instructions for configuring OAuth credentials are here: <https://ucsb-cs156.github.io/topics/oauth/oauth_google_setup.html>
                  * Then you need to use the instructions here to configure the environment variables `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`: <https://ucsb-cs156.github.io/topics/dokku/environment_variables.html>
            - [ ] Everyone on the team, and the instructor and TAs, are all able to 
                  login with OAuth and see that they have admin privileges.
            - [ ] Initially, the `main` branch is deployed and works properly (later, you will deploy your own branches to this 
                  instance as you test them before merging.)     
            - [ ] HTTPS is configured for that app (see: <https://ucsb-cs156.github.io/topics/dokku/enabling_https.html>)
=======
            This issue should be completed *after* the issue "${{env.name}} - Create personal dokku dev deployment"

            # Overview

            This issue involves creating the database table and migration file for `${{env.name}}`.

            For step-by-step instructions, please see these portions of the
            lab writeup:

            * <https://ucsb-cs156.github.io/s24/lab/team02.html#the-two-database-tables-in-the-starting-code>
            * <https://ucsb-cs156.github.io/s24/lab/team02.html#your-task-add-crud-for-additional-database-tables>
            * <https://ucsb-cs156.github.io/s24/lab/team02.html#adding-a-database-table>
            

            # Acceptance Criteria:
            
            - [ ] There is an `@Entity` class called ${{env.name}}.java
            - [ ] There is a `@Repository` class called ${{env.name}}Repository.java
            - [ ] There is a database migration file called ${{env.name}}.json
            - [ ] When you start up the repo on localhost, you can see the table
                  using the H2 console (see the file [`docs/h2-database.md`](/ucsb-cs156-s24/STARTER-team02/blob/main/docs/h2-database.md) for 
                  instructions.)
            - [ ] When you deploy the app to Dokku, you can see the table
                  using the `dokku postgres:connect team02-db` command
                  (use `\dt` to list the tables) (See <https://ucsb-cs156.github.io/topics/dokku/postgres_database.html#postgres-command-line> for more info.)
          
            # What to do next

            When you've met all of the acceptance criteria:

            **Make a PR**: Do a PR for this branch, being sure to enter a [reasonable title](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-titles)
            and [description](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-descriptions).

            In the description, include the text "Closes #n" where `n` is the number of
            this issue.

            Then ask for a team member to review your PR.

            Finally: drag this issue from "In Progress" to "In Review".
      
            **Review Others' PRs**: Next, see if there are any PRs that need to be code reviewed and merged.  Unless you are the
            first person on your team to complete a PR, there likely is at least one.
            See: 
            * [General Code Review Advice](https://ucsb-cs156.github.io/topics/code_reviews/)
            * [Performin Code Reviews on Github](https://ucsb-cs156.github.io/topics/code_reviews/code_reviews_github.html)

            **Start your next issue **: Then, find the issue for 
            "Create `${{env.name}}Controller..." on the Kanban board in the ToDo column.
            
            * Assign it to yourself
            * Drag into "In Progress"
            * Create a new branch, starting from the branch for the issue you just finished.
            * Start on the new issue.
>>>>>>> starter/main

            # What to do next

            Next:
            * Drag the issue for "${{env.name}} - Create personal dokku dev deployment" directly into the "Done" column (we don't do code review on setup tasks like this one.)
            * Locate the issue: "Copy files for Backend CRUD API <tt>${{env.name}}</tt> from ${{env.PREV_ASSIGNMENT}}" on the Kanban board.
            * Assign that issue to yourself
            * Drag it into the "In Progress" column.
            * Start a new branch.  The new branch name is something like `xy-${{env.name}}-backend`
              <pre>
              git fetch
              git checkout main
              git pull origin main
              git checkout -b <i>your-branch-name</i>
              </pre>

      - name: Backend CRUD API
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
        with:
          token: ${{ github.token }}
<<<<<<< HEAD
          labels: "${{env.name}}"
          title: Copy files for Backend CRUD API `${{env.name}}` from ${{env.ASSIGNMENT}}
          body: |
=======
          title: Create `${{env.name}}Controller`, add `GET` (index) and `POST` (create)
          labels: "${{env.name}}"
          body: |

              # Dependencies

              This issue should be completed *after* the issue with the title "Create database table for ${{env.name}}"

              # Overview

              In this issue, you'll create a *Controller*.  In the Spring web framework, a Controller is a file that maps request URLs (e.g. `/api/${{env.name}}/all` to some code that runs to produces the response to that request.
              
              (1) First locate the directory where the Java source code files for controllers can be found:
              
              * [`src/main/java/edu/ucsb/cs156/example/controllers`](https://github.com/ucsb-cs156-s24/STARTER-team02/tree/main/src/main/java/edu/ucsb/cs156/example/controllers) 
              
              (2) Then, determine which example file you are going to use as a basis for your controller by reading the team02 instructions about the `@Id` field here: <https://ucsb-cs156.github.io/s24/lab/team02.html#two-types-of-id-values-for-an-entity-class>
              
              The two candidates are:
              * `UCSBDatesController.java` (if your database table a numeric `@Id` field)
              * `UCSBDiningCommonsController.java` (if your database table uses a string field as it's `@Id` field)

              Keep this file open in one window; you'll need this as source material for the file you are about to create.

              (3) In a separate window, create a new file called `${{env.name}}Controller.java` in the `src/main/java/edu/ucsb/cs156/example/controllers` directory.
              
              From the example file, copy over:
              * all of the imports
              * the top level class annotations (e.g. `@Tag`, `@RequestMapping`, `@RestController` and `@Slf4j`) adjusting them as needed
              * the `@Autowired` declaration of the repository class for your database table; this gives you access to the database table.  The `@Autowired` declaration signals
                the Spring boot framework to automatically invoke the constructor for this class so that you don't have to.  Using `@Autowired`
                also allows the code to automatically switch between using a real database when running as a web app,
                or a "mock" database when we do unit testing of the controller methods.

              (4) Don't copy over all of the methods yet; just copy over these two methods with these annotations:
              
              | Annotation | Purpose |
              |-|-|
              | `@GetMapping("/all")`   | Get all records in the table and return as a JSON array |
              | `@PostMapping("/post")` | Use the data in the input parameters to create a new row in the table and return the data as JSON |
              
              (5) Edit the names of the fields, etc. to match your database table.

              (6) Next, use Swagger to see if your methods work.  Debug until you get correct results using Swagger.
              
              (7) When your interactive testing works, we'll move on to creating automated tests.  Locate the directory for controller tests:
              
              * [`src/test/java/edu/ucsb/cs156/example/controllers`](https://github.com/ucsb-cs156-s24/STARTER-team02/tree/main/src/test/java/edu/ucsb/cs156/example/controllers)  

              Find the file with tests for the controller you used as a basis for your controller file, 
              i.e. 

              * `UCSBDatesControllerTests.java` (if your database table a numeric `@Id` field)
              * `UCSBDiningCommonsControllerTests.java` (if your database table uses a string field as it's `@Id` field)

              Keep this file open in one window; you'll need this as source material for the file you are about to create.

              (8) In a separate window, create a new file called `${{env.name}}ControllerTests.java` in the `src/test/java/edu/ucsb/cs156/example/controllers` directory.

              (9) From the source file you identified in step (7) above, copy over:
              
              * all of the imports
              * the  `@WebMvcTest(...)` annotation (be sure to change the parameter here to the name of the controller test you are testing; forgetting to do so is a common source of errors)
              * the `@Import(TestConfig.class)` annotation (this one stays exactly as it is)
              * the `@MockBean` declaration for the repository for your new database table; this creates a "mock" (i.e. "fake") database object using a Java package called `Mockito`)
              * the `@MockBean` declaration for the `UserRepository`; this is needed so that we can work with the mock users to test what happens in various scenarios: user not logged in, regular user logged in, admin user logged in
              
              Be sure to change the name of the controller class to match the one for your database table.

              (10) Next, copy over just the tests that pertain to the methods you defined in your controller so far, i.e. the ones under the comments:
              * `// Tests for GET /api/ucsbdiningcommons/all`
              * `// Tests for POST /api/ucsbdiningcommons...`

              You'll see additional tests for another `GET` method, as well as `DELETE` and `PUT`; we don't want
              those tests yet (that's a later issue).

              (11) Check test coverage with `mvn test jacoco:report`; to read the report, open `target/site/jacoco/index.html` in a web browser. Iterate until you have 100% line/branch coverage.
              
              (12) Check test coverage with `mvn test pitest:mutationCoverage`; to read the report, open `target/pit-reports/index.html` in a web browser. Iterate until there are no surviving mutations (e.g. `>> Generated 61 mutations Killed 61 (100%)`).  You may ignore line coverage of less than 100% reported by pitest (e.g. this is fine: `>> Line Coverage: 171/175 (98%)`).
>>>>>>> starter/main

            # Dependencies

<<<<<<< HEAD
            Do the "Create personal dokku dev deployment" issue first.
=======
              - [ ] There is a controller file `${{env.name}}Controller.java`
                in the expected directory.
              - [ ] In `${{env.name}}Controller.java` there is 
                code for a `GET /api/${{env.name}}/all` endpoint 
                that returns a JSON list of all `${{env.name}}`s in the database.
                (We sometimes call this an *index* action since it lists all
                items in the database.)
              - [ ] In `${{env.name}}Controller.java` there is 
                code for a `POST /api/${{env.name}}/post` endpoint
                that can be used to create a new entry in the table. (This
                is a *create* action.)
              - [ ] The Swagger-UI endpoints for these are well documented so that
                any member of the team can understand what they are for and
                how to use them.
              - [ ] The `POST` endpoint works as expected, in the sense that new
                records can be added to the database (on localhost).
              - [ ] The `GET` endpoint works as expected, in the sense that the new
                records that are added show up (on localhost).
              - [ ] The `GET` and `POST` endpoints work as expected when the 
                app is deployed to Dokku.
              - [ ] There is full test coverage (Jacoco) for the methods in 
                `${{env.name}}Controller.java`
              - [ ] There is full mutation test coverage (Pitest) for the methods in
                `${{env.name}}Controller.java`

              # Next issue

              # What to do next

              When you've met all of the acceptance criteria:
  
              **Make a PR**: Do a PR for this branch, being sure to enter a [reasonable title](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-titles)
              and [description](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-descriptions).
  
              In the description, include the text "Closes #n" where `n` is the number of
              this issue.
  
              Then ask for a team member to review your PR.
  
              Finally: drag this issue from "In Progress" to "In Review".
        
              **Review Others' PRs**: Next, see if there are any PRs that need to be code reviewed and merged.  Unless you are the
              first person on your team to complete a PR, there likely is at least one.
              See: 
              * [General Code Review Advice](https://ucsb-cs156.github.io/topics/code_reviews/)
              * [Performin Code Reviews on Github](https://ucsb-cs156.github.io/topics/code_reviews/code_reviews_github.html)
  
              **Start your next issue **: 
              
              Now you can complete these in any order:
              * Add `GET` (show) endpoint for a single record in ${{env.name}} table
              * Add `PUT` (edit) endpoint for a single record in ${{env.name}} table
              * Add `DELETE` endpoint for a specific record in ${{env.name}} table.
              
              Find the issue you are going to work on next on the Kanban board.
              
              * Assign it to yourself
              * Drag into "In Progress"
              * Create a new branch, starting from the branch for the issue you just finished.
              * Start on the new issue.

      - name:  Add `GET` (show) endpoint for a single record in table
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
        with:
          token: ${{ github.token }}
          title: Add `GET` (show) endpoint for a single record in ${{env.name}} table
          labels: "${{env.name}}"
          body: |

            # Dependencies

            This issue should be completed *after* the issue with the title "Create `${{env.name}}Controller`..."

            # Overview
            
            In this issue, we add one more method from the example Controller used as a basis for our code; namely the method with the annotation shown below:
            
            | Annotation | Purpose |
            |-|-|
            |`@GetMapping("")` | Get a single record from the table; use the value passed in as a `@RequestParam` to do a lookup by id.  If a matching row is found, return the row as a JSON object, otherwise throw an `EntityNotFoundException`. |
                       
            Add `GET` (show) endpoint for a single record in ${{env.name}} table
>>>>>>> starter/main

            Also add the tests for this endpoint.
            
            # Acceptance Criteria:
<<<<<<< HEAD

            - [ ] Backend API routes for CRUD operations for `${{env.name}}` are
                  available in Swagger (following the criteria from ${{env.ASSIGNMENT}})

            # Implementation Details:
            - [ ] Find `${{env.name}}.java` in your ${{env.ASSIGNMENT}} project in the directory 
                  `src/main/java/edu/ucsb/cs156/example/entities` 
                  and copy it into your ${{env.ASSIGNMENT}} project in the same directory.
            - [ ] Do the same for  `${{env.name}}Repository.java` from the directory
                  `src/main/java/edu/ucsb/cs156/example/repositorires`
            - [ ] Do the same for `${{env.name}}Controller.java` from the directory
                  `src/main/java/edu/ucsb/cs156/example/controllers`
            - [ ] Do the same for `${{env.name}}ControllerTests.java` from the directory
                  `src/test/java/edu/ucsb/cs156/example/controllers`   
            - [ ] Do the same for your database migration file for $${{env.name}}, under `/src/main/resources/db/migration/changes`       
            - [ ] With these files in place, visit swagger and make sure 
                  the CRUD operations for `${{env.name}}` are working properly.
=======
            
            - [ ] In `${{env.name}}Controller.java` there is code for an 
                  endpoint `GET /api/${{env.name}}?id=123` endpoint 
                  that returns the JSON of the database record with id 123 if it
                  exists, or a 404 and the error message `id 123 not found` if it
                  does not.
            - [ ] The Swagger-UI endpoints for this endpoint is well documented
                  so that any member of the team can understand how to use it.
            - [ ] The endpoint works as expected on localhost.
            - [ ] The endpoint works as expected when deployed to Dokku.
            - [ ] There is full test coverage (Jacoco) for the new code in 
                  `${{env.name}}Controller.java`
            - [ ] There is full mutation test coverage (Pitest) for new code in
                  `${{env.name}}Controller.java`

            # What to do next

            Do a PR, following all of the usual steps (title, description, `Closes #n` text,
            dragging issue to "In Review", requesting reviewers).

            Check to see if any fellow team members PRs need to be reviewed.
            
            Then, assign yourself the next incomplete issue for your database table (`${{env.name}}`)

            Follow all the usual steps (assign to self, drag to "In Progress", start new branch.)

            When you are done with all issues for `${{env.name}}`, please give your full attention to 
            helping others on your team to complete the sprint, so that the team
            is ready to submit on Canvas by the deadline.
            
            
      - name: Add `PUT` (edit) endpoint for a single record in table
>>>>>>> starter/main

            # What to do next

            **Make a PR**: When you've met all of the acceptance criteria, do a PR for this branch,
            being sure to enter a [reasonable title](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-titles)
            and [description](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-descriptions).

            In the description, include the text "Closes #n" where `n` is the number of
            this issue.

            It is also helpful to include a screenshot of the Swagger endpoints so that
            the person reviewing your PR knows what to test. It is helpful to 
            deploy your branch to your dokku dev instance, and include a link to the 
            swagger page on your dokku instance.

            Then ask for a team member to review your PR.

            Finally: drag this issue from "In Progress" to "In Review".

            **Review Others' PRs**: Next, see if there are any PRs that need to be code reviewed and merged.  Unless you are the
            first person on your team to complete a PR, there likely is at least one.
            See: 
            * [General Code Review Advice](https://ucsb-cs156.github.io/topics/code_reviews/)
            * [Performing Code Reviews on Github](https://ucsb-cs156.github.io/topics/code_reviews/code_reviews_github.html)

            **Start your next issue**: Then, find the issue for "Create fixtures for `${{env.name}}`" on the Kanban board in the ToDo column.

            * Assign it to yourself
            * Drag into "In Progress"
            * Create a new branch, starting from the branch for the issue you just finished.
            * Start on the new issue.

      - name: Fixtures
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
          fixtures: ${{ fromJSON(env.FIXTURES)[matrix.api] }}
        with:
          token: ${{ github.token }}
          labels: "${{env.name}}"
          title: Create fixtures for `${{env.name}}`
          body: |

            # Dependencies

            None; this issue should be done first before other issues for the
            ${{env.name}} table

            # Acceptance Criteria:

            - [ ] In the frontend directory `frontend/src/main/fixtures` there is a file called 
                  `${{env.fixtures}}Fixtures.js` that contains Javascript fixtures
                  for the database table that is similar to the `restaurantFixtures.js` 
                  and `ucsbDatesFixtures.js` files in the same directory.
            - [ ] Each example should correspond to the JSON format of an object returned by 
                  the GET API endpoint from ${{env.ASSIGNMENT}} for the `${{env.name}}` database table object.

            # What to do next

            **Make a PR**: When you've met all of the acceptance criteria, do a PR for this branch,
            being sure to enter a [reasonable title](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-titles)
            and [description](https://ucsb-cs156.github.io/topics/pull_requests.html#pr-descriptions).

            In the description, include the text "Closes #n" where `n` is the number of
            this issue.

            Then ask for a team member to review your PR, and drag this issue from "In Progress" to "In Review".

            **Review Others' PRs**: Next, see if there are any PRs that need to be code reviewed and merged.  Unless you are the
            first person on your team to complete a PR, there likely is at least one.
            See: 
            * [General Code Review Advice](https://ucsb-cs156.github.io/topics/code_reviews/)
            * [Performing Code Reviews on Github](https://ucsb-cs156.github.io/topics/code_reviews/code_reviews_github.html)

            **Start your next issue**: Then, find the issue for "Form Component for `${{env.name}}` plus tests" on the Kanban board in the ToDo column.

            * Assign it to yourself
            * Drag into "In Progress"
            * Create a new branch, starting from the branch for the issue you just finished.
            * Start on the new issue.

      - name: Form Component
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
        with:
          token: ${{ github.token }}
<<<<<<< HEAD
          labels: "${{env.name}}"
          title: Form Component for `${{env.name}}` plus tests

          body: |

            # Dependencies

            Complete the following issues first:
            * Create fixtures for ${{env.name}}
            * Set up GitHub Pages (for Storybook)

            # Acceptance Criteria:

            - [ ] A form called `${{env.name}}Form` is visible in the storybook
                  accessible on the Github Pages link.
=======
          title: Add `PUT` (edit) endpoint for a single record in ${{env.name}} table
          labels: "${{env.name}}"
          body: |

            # Dependencies

            This issue should be completed *after* the issue with the title "Create `UCSBDiningCommonsMenuItemController`..."

            # Overview
            
            In this issue, we add one more method from the example Controller used as a basis for our code; namely the method with the annotation shown below:
            
            | Annotation | Purpose |
            |-|-|
            |`@PutMapping("")` | Get a single record from the table; use the value passed in as a `@RequestParam` to do a lookup by id.  If a matching row is found, update that row with the values passed in as a JSON object. If a matching row is not found, throw an `EntityNotFoundException`. |
                       

            Note that while it isn't strictly necessary, it may be a good idea to implement `GET` for a single item
            first; when using `PUT` manually, it's convenient to be able to copy/paste the JSON representation of the data from the
            `GET` by id method, paste it into the swagger interface, then edit it to make the changes you want before clicking to
            submit the request.
            
            You'll need to copy over the code for the PUT method from the example controller, 
            and then paste those into `${{env.name}}Controller.java` and edit them to match your database table.
        
            Then, copy over the tests that pertain to the PUT method from the example controller,
            paste those into `${{env.name}}ControllerTests.java` and edit them to match your database table.

            # Acceptance Criteria:
            
            - [ ] In `${{env.name}}Controller.java` there is code for an 
                  endpoint `PUT /api/${{env.name}}?id=123` endpoint 
                  that accepts JSON for a new set of values for the database
                  fields other than `id`, and updates the values of those fields.
            - [ ] The Swagger-UI endpoints for this endpoint is well documented
                  so that any member of the team can understand how to use it.
            - [ ] The endpoint works as expected on localhost.
            - [ ] The endpoint works as expected when deployed to Dokku.
            - [ ] There is full test coverage (Jacoco) for the new code in 
                  `${{env.name}}Controller.java`
            - [ ] There is full mutation test coverage (Pitest) for new code in
                  `${{env.name}}Controller.java`   

            # What to do next

            Do a PR, following all of the usual steps (title, description, `Closes #n` text,
            dragging issue to "In Review", requesting reviewers).

            Check to see if any fellow team members PRs need to be reviewed.
            
            Then, assign yourself the next incomplete issue for your database table (`${{env.name}}`)

            Follow all the usual steps (assign to self, drag to "In Progress", start new branch.)

            When you are done with all issues for `${{env.name}}`, please give your full attention to 
            helping others on your team to complete the sprint, so that the team
            is ready to submit on Canvas by the deadline.
            
>>>>>>> starter/main

            - [ ] The form has all the fields that are in the database table 
                  the form fields are labelled with user-friendly names corresponding
                  to the database table column names.

            - [ ] The form has suitable validations for all fields, indicating which fields
                  are required to be non-blank, and any validation that should be performed
                  (e.g. on dates, time values, numeric values with restricted ranges etc.).
                  You can use regular expressions for this, or any of the other validations
                  features of `react-query-form`, using the `register` feature, documented here:
                  <https://www.react-hook-form.com/api/useform/register/>.  Consult
                  both the `RestaurantForm.js` and `UCSBDatesForm.js` files for examples.

            - [ ] If there are date/time fields, use a date/time picker similar
                  to the one in the `UCSBDatesForm` component.  (If this is
                  not applicable to your table, then you can skip this step.)

            - [ ] The `${{env.name}}Form.stories.js` file should have at least one story 
                  for a create scenario, and another for an update scenario.
                  
            - [ ] The PR description where the code addressing this issue is submitted contains
                  a screenshot of the new form (since this is a frontend change).

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a link to the published storybook for the PR.

            # Implementation Details:

            - [ ] Under `frontend/src/main/components/${{env.name}}/` there is a file
                  called `${{env.name}}Form` modelled after 
                  the files `RestaurantForm.js` and/or `UCSBDatesForm.js`

            - [ ] Change the form fields so that they correspond to 
                  the form fields of your database record.  If there are 
                  are labelled with user-friendly names corresponding
                  to the database table column names.

            - [ ] Add suitable validations for all of your fields indicating which fields
                  are required to be non-blank, and any validation that should be performed
                  (e.g. on dates, time values, numeric values with restricted ranges etc.).
                  You can use regular expressions for this, or any of the other validations
                  features of `react-query-form`, using the `register` feature, documented here:
                  <https://www.react-hook-form.com/api/useform/register/>. 
                  Consult both the `Restaurant` and `UCSBDates` examples for guidance.

            - [ ] The form should take a prop called `initialContents` which is either 
                  undefined, or an object that has the same fields as the database table.
                  When passed, it indicates that the form is being used to edit an existing
                  object.  The `id` field should be displayed as a read-only field,
                  and the other fields are pre-populated with the values from the object.

            - [ ] When the `initialContents` is undefined, it indicates that the form is
                  being used to create a new object.  Therefore, if the id field is autogenerated,
                  it should not be displayed on the form, and other form values should 
                  be either empty, or populated with default or example values (as appropriate).
                  
            - [ ] The form should take prop called `submitAction` which is passed to the
                  `handleSubmit` function returned by `useForm`, as in the examples
                  `RestaurantForm.js` and `UCSBDatesForm.js`

            - [ ] The form should take a prop called `buttonLabel` with a default value
                  of `Create`.  The value of this prop is used as the label for the button
                  as shown in  `RestaurantForm.js` and `UCSBDatesForm.js`.            

            - [ ] Under `frontend/src/test/components/${{env.name}}/` create a file called `${{env.name}}Form.test.js` modelled after the files `RestaurantForm.test.js` and `UCSBDatesForm.test.js`.

            - [ ] Under `frontend/src/stories/components/${{env.name}}/` create a file called `${{env.name}}Form.stories.js` modelled after the files `RestaurantForm.stories.js` and `UCSBDatesForm.stories.js`.
                  
            # Notes

            * For *this* issue, it is not necessary that the form be linked to a
              page that connects it to the backend; that will be done in a later issue.

            * This issue illustrates how it is possible to create at least part of the frontend
              for a feature even if/when the backend is not yet complete.

            * It also illustrates how we can create a component that can be reused, in this
              case for both creating and editing a database record.

            # Reminders (all from `frontend` directory):

            * Always start by setting your node version with ${{env.NVM_USE}}
            * To run storybook locally: `npm run storybook`.
            * To run tests locally: `npm test`.
            * Quickly test coverage locally: `npm run coverage`
            * Check linting locally: `npx eslint --fix .`
            * Check mutation coverage locally (slow): `npx stryker run`
            * Check mutation coverage of single file (faster): `npx stryker run -m src/main/components/${{env.name}}/${{env.name}}Form.js`

            # What to do next

            Do a PR, following all of the usual steps (title, description, `Closes #n` text,
            dragging issue to "In Review", requesting reviewers).

            Check to see if any fellow team members PRs need to be reviewed.

            Then, assign yourself the issue "Table Component for `${{env.name}}` plus tests"
            following all the usual steps (assign to self, drag to "In Progress", start new branch.)

      - name: Table Component
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
        with:
          token: ${{ github.token }}
<<<<<<< HEAD
          labels: "${{env.name}}"
          title: Table Component for `${{env.name}}` plus tests

=======
          title: Add `DELETE` endpoint for a specific record in ${{env.name}} table.
          labels: "${{env.name}}"
>>>>>>> starter/main
          body: |

            # Dependencies

<<<<<<< HEAD
            Complete the following issues first:
            * Create fixtures for ${{env.name}}
            * Set up GitHub Pages (for Storybook)

            # Acceptance Criteria:

            - [ ] A table called `${{env.name}}Table` is visible in the storybook
                  accessible on the Github Pages link.
                  
            - [ ] The table has all the fields that are in the database table 
                  labelled with user-friendly names corresponding to the database table column names.

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a screenshot of the new table (since this is a frontend change).

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a link to the published storybook for the PR, linking directly to the story 
                  for the new `${{env.name}}Table` component.

            # Implementation Details

            - [ ] Under `frontend/src/main/components/${{env.name}}/` create a file called `${{env.name}}Table`,
                  modelled after the files `RestaurantTable.js` and `UCSBDatesTable.js`

            - [ ] Under `frontend/src/test/components/${{env.name}}/` create a file called `${{env.name}}Table.test.js` 
                  modelled after the files `RestaurantTable.test.js and `UCSBDatesTable.test.js`.

            - [ ] Under `frontend/src/stories/components/${{env.name}}/` create a file called `${{env.name}}Table.stories.js`,
                  modelled after the files `RestaurantTable.stories.js` and `UCSBDatesTable.stories.js`.
                    
            # Notes

            * For *this* issue, tt is not necessary that the table be linked to a
              page that connects it to the backend; that will be done in a later issue.

            * This issue illustrates how it is possible to create at least part of the frontend
              for a feature even if/when the backend is not yet complete.

            # Reminders (all from `frontend` directory):

            * Always start by setting the node version with ${{env.NVM_USE}}
            * To run storybook locally: `npm run storybook`.
            * To run tests locally: `npm test`.
            * Quickly test coverage locally: `npm run coverage`
            * Check linting locally: `npx eslint --fix .`
            * Check mutation coverage locally (slow): `npx stryker run`
            * Check mutation coverage of single file (faster): `npx stryker run -m src/main/components/${{env.name}}/${{env.name}}Form.js`
=======
            This issue should be completed *after* the issue with the title "Create `${{env.name}}Controller`..."

            # Overview
            
            In this issue, we add one more method from the example Controller used as a basis for our code; namely the method with the annotation shown below:
            
            | Annotation | Purpose |
            |-|-|
            |`@DeleteMapping("")` | Delete a single record from the table; use the value passed in as a `@RequestParam` to do a lookup by id. If a matching row is not found, throw an `EntityNotFoundException`. |
                   
            You'll need to copy over the code for the DELETE method from the example controller, 
            and then paste those into `${{env.name}}Controller.java` and edit them to match your database table.
        
            Then, copy over the tests that pertain to the DELETE method from the example controller,
            paste those into `${{env.name}}ControllerTests.java` and edit them to match your database table.

            # Acceptance Criteria:
            
            - [ ] In `${{env.name}}Controller.java` there is code for an 
                  endpoint `DELETE /api/${{env.name}}?id=123` endpoint 
                  that deletes the record if it exists, and returns 200 (ok) and 
                  the text `record 123 deleted`, or returns 404 (Not Found) and
                  the text `record 123 not found` if it does not.
            - [ ] The Swagger-UI endpoints for this endpoint is well documented
                  so that any member of the team can understand how to use it.
            - [ ] The endpoint works as expected on localhost.
            - [ ] The endpoint works as expected when deployed to Dokku.
            - [ ] There is full test coverage (Jacoco) for the new code in 
                  `${{env.name}}Controller.java`
            - [ ] There is full mutation test coverage (Pitest) for new code in
                  `${{env.name}}Controller.java`
>>>>>>> starter/main

            # What to do next

            Do a PR, following all of the usual steps (title, description, `Closes #n` text,
            dragging issue to "In Review", requesting reviewers).

            Check to see if any fellow team members PRs need to be reviewed.
<<<<<<< HEAD

            Then, assign yourself the issue "Copy Placeholders for `${{env.name}}` pages; add to App.js/AppNavbar.js"

            Follow all the usual steps (assign to self, drag to "In Progress", start new branch.)

      - name: Copy Placeholder pages; add to App.js/AppNavbar.js
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
          frontend_url: ${{ fromJSON(env.FRONTEND_URL)[matrix.api] }}
        with:
          token: ${{ github.token }}
          labels: "${{env.name}}"
          title: Copy Placeholders for `${{env.name}}` pages; add to App.js/AppNavbar.js
          body: |

            # Dependencies

            None: can be done in parallel with other issues

            # Discussion

            In this issue, you'll set up placeholders for the three pages you are adding to the app.  

            These placeholder components are temporary, but they are necessary so that you can 
            add routes to the pages in `frontend/src/App.js` and add a link to the `/${{env.frontend_url}}` 
            name in to the Navigation Bar of the app in `frontend/src/components/AppNavbar.js`.

            Note that the contents of the placeholder pages and tests are temporary, 
            and will be replaced in a later issue.  However, the changes you make in `App.js`
            and `AppNavbar.js` will be permanent.

            The reason for the placeholder code is that we can't really test the
            changes to `App.js` and `AppNavbar.js` until at least some placeholder 
            component for the pages exists, and we can't really test the new pages unless they 
            are routed to in the app.  The placeholder solves this ["chicken/egg" problem](https://en.wikipedia.org/wiki/Chicken_or_the_egg).

            # Acceptance Criteria

            - [ ] On the main navigation bar, there is a link to `${{env.name}}`
                  that takes the user to the `${{env.name}}IndexPage` page (a placeholder for now) 
                  at the url `/${{env.frontend_url}}`.
            - [ ] The `${{env.name}}IndexPage` page has a link to the `${{env.name}}CreatePage` page 
                  at the url `/${{env.frontend_url}}/create`.
            - [ ] The `${{env.name}}IndexPage` page has a link to the `${{env.name}}EditPage` page 
                  at the url `/${{env.frontend_url}}/edit/1`.

            # Implementation Steps    
             
            - [ ] Under `frontend/src/main/pages/${{env.name}}/` create three files
                  called `${{env.name}}CreatePage.js`, `${{env.name}}EditPage.js`, `${{env.name}}IndexPage.js`, modelled after 
                  `PlaceholderCreatePage.js`, `PlaceholderEditPage.js`, `PlaceholderIndexPage.js`.
                  The only change that should be needed is the name of the component
                  (see "Notes" below)
                  
            - [ ] Under `frontend/src/tests/pages/${{env.name}}/` create three files called `${{env.name}}CreatePage.test.js`, `${{env.name}}EditPage.test.js`, `${{env.name}}IndexPage.test.js`  modelled after `PlaceholderCreatePage.test.js`, `PlaceholderEditPage.test.js`, `PlaceholderIndexPage.test.js`. The only change that should be needed is the name of the component 
                  being imported.

            - [ ] In `frontend/src/App.js`, there is a section of code that establishes the routes to the pages for the `${{env.name}}` components that looks similar to the ones for `Restaurants`, `UCSBDates`, and the `Placeholder`.  Copy/paste this code, changing, `Restaurant` to  `${{env.name}}`, and `/restaurants` to `/${{env.frontend_url}}` 
                  
            - [ ] In `frontend/src/main/components/Nav/AppNavbar.js`,add a section of code that establishes the navbar link for `${{env.name}}`.  It should look similar to this code that establishes the link for `Restaurants`. Copy/paste this code, changing `/restaurants` to  `/${{env.frontend_url}}`, and `Restaurants` to `${{env.name}}`
                 
            - [ ] Fire up the app on localhost and make sure that you can navigate to the pages for ${{env.name}}.  You should see pages similar to the ones at the `Placeholder` link on the navbar.

            # Notes

            The changes you will need to make from the examples are minimal.

            In the three page components, typically you will only need to change the 
            name of the default export, changing `Placeholder` to `${{env.name}}`


            ```js
            export default function PlaceholderCreatePage() {
            ```

            In `App.js`, you will need to:
            * Add import statements for the three page components
            * Copy/paste the section of code below, changing `/restaurants`  to `/${{env.frontend_url}}` and `Restaurant` to `${{env.name}}`
                                 
            ```js
            {
                  hasRole(currentUser, "ROLE_USER") && (
                    <>
                      <Route exact path="/restaurants" element={<RestaurantIndexPage />} />
                    </>
                  )
            }
            {
                  hasRole(currentUser, "ROLE_ADMIN") && (
                    <>
                      <Route exact path="/restaurants/edit/:id" element={<RestaurantEditPage />} />
                      <Route exact path="/restaurants/create" element={<RestaurantCreatePage />} />
                    </>
                  )
            }
            ```

            In `AppNavbar.js`, copy/paste this section of code, and change  `/restaurants` to `/${{env.frontend_url}}` and `Restaurants` to `${{env.name}}`:

            ```js
            {
                  hasRole(currentUser, "ROLE_USER") && (
                    <>
                      <Nav.Link as={NavLink} to="/restaurants">Restaurants</Nav.Link>
                    </>
                  )
            }
            ```
            # Reminders (all from `frontend` directory):

            * Always start by setting your node version with ${{env.NVM_USE}}
            * To run storybook locally: `npm run storybook`.
            * To run tests locally: `npm test`.
            * Quickly test coverage locally: `npm run coverage`
            * Check linting locally: `npx eslint --fix .`
            * Check mutation coverage locally (slow): `npx stryker run`
            * Check mutation coverage of single file (faster): `npx stryker run -m src/main/components/Nav/AppNavbar.js`

            # What to do next

            * Do a PR (following the usual steps).
            * Check for other PRs 
            * Start work on "Create Page for `${{env.name}}` plus tests and stories" (following the usual steps for a new issue)

      - name: Create Page
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
          frontend_url: ${{ fromJSON(env.FRONTEND_URL)[matrix.api] }}

        with:
          token: ${{ github.token }}
          labels: "${{env.name}}"
          title: Create Page for `${{env.name}}` plus tests and stories

          body: |
            # Dependencies

            Complete the following issues first:
            * Create fixtures for ${{env.name}}
            * Form Component for ${{env.name}}
            * Copy Placeholders for `${{env.name}}` pages; add to App.js/AppNavbar.js

            # Acceptance Criteria:

            - [ ] When you navigate to `/${{env.frontend_url}}/create` in the URL bar, 
                  there is page that allows the user to create a new ${{env.name}} record.

            - [ ] When you enter data into the form and click the submit button,
                  if the data is valid, the data is sent to the server, 
                  a new ${{env.name}} record is created,and the user is routed to the 
                  `/${{env.frontend_url}}` route for the `${{env.name}}IndexPage` page.

            - [ ] When you enter data into the form and click the submit button,
                  if the data is not valid,appropriate error messages are displayed, 
                  the data is NOT sent to the server, a new ${{env.name}} record is NOT created,
                  and the user remains on the `${{env.frontend_url}}/create` page.

            - [ ] When you submit valid data to the page and click submit, a new valid database
                  entry is stored in the database.  (You can verify this by using the swagger
                  endpoint to view the current data in the table.)

            - [ ] The PR description has step-by-step descriptions for testing the new page, along
                  with screenshots, so that someone reviewing the PR will know what to do to test
                  it, and what it is supposed to look like when it functions correctly.

            - [ ] The PR description has a link to the storybook entry for the new page.

            # Implementation Details

            - [ ] Before starting, refamiliarize yourself with the backend CRUD API endpoints for 
                  `${{env.name}}` by looking at the swagger page.  You are going to be copy/pasting
                  code from the `Restaurant` and `UCSBDates` components. Those use backend api endpoints
                  that are similar to the ones for `${{env.name}}`, but not identical.  You will need
                  to know the exact name of the API endpoints for `${{env.name}}` in order to
                  be sure that your frontend code is calling the correct backend endpoints.

            - [ ] In `${{env.name}}CreatePage.js`, replace the code from `PlaceholderCreatePage.js` 
                  with code modelled after the files `RestaurantCreatePage.js` and/or `UCSBDatesCreatePage.js`
                  that is appropriate to your `${{env.name}}` table. Be sure to get the API endpoint names correct for your `${{env.name}}` table.

            - [ ] In `${{env.name}}CreatePage.test.js`, replace the code from `PlaceholderCreatePage.test.js` 
                  with code modelled after  the files `RestaurantCreatePage.test.js` and/or `UCSBDatesCreatePage.test.js`
                  appropriate to your `${{env.name}}` table.  Be sure to get the API endpoint names correct for your `${{env.name}}` table.

            - [ ] Under `frontend/src/stories/pages/${{env.name}}/` create a file called `${{env.name}}CreatePage.stories.js` 
                  modelled after the files `RestaurantCreatePage.stories.js` and/or `UCSBDatesCreatePage.stories.js`.

            # Reminders (all from `frontend` directory):
                  
            * Always start by setting your node version with ${{env.NVM_USE}}
            * To run storybook locally: `npm run storybook`.
            * To run tests locally: `npm test`.
            * Quickly test coverage locally: `npm run coverage`
            * Check linting locally: `npx eslint --fix .`
            * Check mutation coverage locally (slow): `npx stryker run`
            * Check mutation coverage of single file (faster): `npx stryker run -m src/main/pages/${{env.name}}/${{env.name}}CreatePage.js`

            # What to do next

            * Do a PR (following the usual steps).
            * Check for other PRs 
            * Start work on "Index Page for `${{env.name}}` plus tests and stories"(following the usual steps for a new issue)

      - name: Index Page
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
          frontend_url: ${{ fromJSON(env.FRONTEND_URL)[matrix.api] }}
        with:
          token: ${{ github.token }}
          labels: "${{env.name}}"
          title: Index Page for `${{env.name}}` plus tests and stories

          body: |

            # Dependencies

            Complete the following issues first:
            * Create fixtures for ${{env.name}}
            * Table Component for ${{env.name}} 
            * Copy Placeholders for `${{env.name}}` pages; add to App.js/AppNavbar.js

            # Acceptance Criteria:

            - [ ] When the user navigates to `/${{env.frontend_url}}` the page will be populated
                  with data all rows in the database, and the user will be able to see
                  all of the data in the table.

            - [ ] When the index page is accessed by an admin user, they will be able to
                  see a button to create a new record, and a button to edit each record,
                  and a button to delete each record.

            - [ ] When the index page is accessed by an regular logged in user, 
                  the buttons to create a new record, edit a record, and delete a record
                  will not be visible in the table.  Logged in users will be able to see
                  the data in the table, but that is all.

            - [ ] When the index page is accessed by an admin user, the edit button will
                  navigate to the URL for the edit page for that record.  (The page should display
                  if the issue to implement it is already completed, or a blank page with the correct
                  URL if it is not.)

            - [ ] When the index page is accessed by an admin user, the delete button will
                  call the endpoint to delete the record from the database, and then refresh
                  the page.  The refreshed page will not show the deleted record.

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a screenshot of the new page (since this is a frontend change).

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a link to the published storybook for the PR, linking directly to the story 
                  for the new `${{env.name}}IndexPage` component.

            # Implementation Details

            - [ ] Before starting, refamiliarize yourself with the backend CRUD API endpoints for 
                  `${{env.name}}` by looking at the swagger page.  You are going to be copy/pasting
                  code from the `Restaurant` and `UCSBDates` components. Those use backend api endpoints
                  that are similar to the ones for `${{env.name}}`, but not identical.  You will need
                  to know the exact name of the API endpoints for `${{env.name}}` in order to
                  be sure that your frontend code is calling the correct backend endpoints.

            - [ ] Modify the `${{env.name}}IndexPage`, replacing the placeholder
                  content with content modelled after the files `RestaurantIndexPage.js`
                  and/or `UCSBDatesIndexPage.js`.  Be sure to get the API endpoint names correct for your `${{env.name}}` table.

            - [ ] Modify `${{env.name}}IndexPage.test.js`  replacing the placeholder
                  content with content modelled after the files `RestaurantIndexPage.test.js`
                  and/or `UCSBDatesIndexPage.test.js`. Be sure to get the API endpoint names correct for your `${{env.name}}` table.

            - [ ] Under `frontend/src/stories/pages/${{env.name}}/` create a file
                  called `${{env.name}}IndexPage.stories.js` modelled after 
                  the files `RestaurantIndexPage.stories.js` and `UCSBDatesIndexPage.stories.js`.

            # Reminders (all in `frontend` directory)

            * Always start by setting your node version with ${{env.NVM_USE}}
            * To run storybook locally: `npm run storybook`.
            * To run tests locally: `npm test`.
            * Quickly test coverage locally: `npm run coverage`
            * Check linting locally: `npx eslint --fix .`
            * Check mutation coverage locally (slow): `npx stryker run`
            * Check mutation coverage of single file (faster): `npx stryker run -m src/main/pages/${{env.name}}/${{env.name}}IndexPage.js`

            # What to do next

            * Do a PR (following the usual steps).
            * Check for other PRs 
            * Start work on "Edit Page for `${{env.name}}` plus tests and stories" (following the usual steps for a new issue)

      - name: Edit Page
        uses: dacbd/create-issue-action@main
        env:
          name: ${{ matrix.api }}
          frontend_url: ${{ fromJSON(env.FRONTEND_URL)[matrix.api] }}

        with:
          token: ${{ github.token }}
          labels: "${{env.name}}"
          title: Edit Page for `${{env.name}}` plus tests and stories
          body: |

            # Dependencies

            Complete the following issues first:
            * Create fixtures for ${{env.name}}
            * Form Component for ${{env.name}}  
            * Copy Placeholders for `${{env.name}}` pages; add to App.js/AppNavbar.js

            # Acceptance Criteria:

            - [ ] When the user navigates to `/${{env.frontend_url}}/edit/:id` where `:id` 
                  is the `id` field of a valid record in the table, the page will be populated
                  with data from that row of the database, and will be able to edit fields
                  from that database record.

            - [ ] Valid changes made on the page are saved to the database when the user clicks
                  the submit button.
            - [ ] Changes made on the page are NOT saved when the page contains invalid data; instead,
                  appropriate error messages are shown.
            - [ ] Changes made on the page are NOT saved when the user clicks the cancel button,
                  and the user is routed back to the previous page they were on (like the "back button").     

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a screenshot of the new page (since this is a frontend change).

            - [ ] The PR description where the code addressing this issue is submitted contains
                  a link to the published storybook for the PR, linking directly to the story 
                  for the new `${{env.name}}EditPage` component.

            # Implementation Details

            - [ ] Before starting, refamiliarize yourself with the backend CRUD API endpoints for 
                  `${{env.name}}` by looking at the swagger page.  You are going to be copy/pasting
                  code from the `Restaurant` and `UCSBDates` components. Those use backend api endpoints
                  that are similar to the ones for `${{env.name}}`, but not identical.  You will need
                  to know the exact name of the API endpoints for `${{env.name}}` in order to
                  be sure that your frontend code is calling the correct backend endpoints.

            - [ ] Replace the placeholder content in `${{env.name}}EditPage.js`
                  with appropriate content from `RestaurantEditPage.js` and/or
                  `UCSBDatesEditPage.js`. Be sure to get the API endpoint names correct for your `${{env.name}}` table.

            - [ ] Replace the placeholder content in `${{env.name}}EditPage.test.js`
                  with appropriate content from `RestaurantEditPage.test.js` and/or
                  `UCSBDatesEditPage.test.js`. Be sure to get the API endpoint names correct for your `${{env.name}}` table.

            - [ ] Under `frontend/src/stories/pages/${{env.name}}/` create a file
                  called `${{env.name}}EditPage.stories.js` modelled after 
                  the files `RestaurantEditPage.stories.js` and/or `UCSBDatesEditPage.stories.js`.

            # Reminders (all from `frontend` directory):

            * Always start by setting the node version with ${{env.NVM_USE}}
            * To run storybook locally: `npm run storybook`.
            * To run tests locally: `npm test`.
            * Quickly test coverage locally: `npm run coverage`
            * Check linting locally: `npx eslint --fix .`
            * Check mutation coverage locally (slow): `npx stryker run`
            * Check mutation coverage of single file (faster): `npx stryker run -m src/main/pages/${{env.name}}/${{env.name}}EditPage.js`

            # What to do next

            When you are done with this issue, you are finished with the frontend CRUD
            operations for `${{env.name}}`.  Now, please give your full attention to 
            helping others on your team to complete the sprint, so that the team
            is ready to submit on Canvas by the deadline.
=======
            
            Then, assign yourself the next incomplete issue for your database table (`${{env.name}}`)

            Follow all the usual steps (assign to self, drag to "In Progress", start new branch.)

            When you are done with all issues for `${{env.name}}`, please give your full attention to 
            helping others on your team to complete the sprint, so that the team
            is ready to submit on Canvas by the deadline.
            
          
>>>>>>> starter/main
